## DMA 总结

### 1. DMA

	DMA(Direct Memory Access)直接存储器访问,在传输过程中不需要CPU干预，可以直接从内存读写数据。
	DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。当CPU初始化这个传输动作，传输动作本身是由DMA控制器来实现和完成的。DMA传输方式无需CPU直接控制传输，也没有中断处理方式那样保留现场和恢复现场过程，通过硬件为RAM和IO设备开辟一条直接传输数据的通道，使得CPU的效率大大提高。

### 2. 缓存一致性
![CPU](https://github.com/Liyaxxx/Photo/blob/main/CPU-Cache.webp "CPU")

	现在 CPU 都是多核的，由于 L1/L2 Cache 是多个核心各自独有的，那么会带来多核心的缓存一致性（Cache Coherence） 的问题，如果不能保证缓存一致性的问题，就可能造成结果错误。

#### 2.1 缓存一致性问题产出的原因
	假设有两个CPU都想访问内存地址A，如果CPU0率先方法A，那么地址A的数据就会先加载到CPU0的缓存中，若CPU1也想访问这个数据，因为地址A的数据此时在系统中有两个副本，一个是内存地址A的，一个是CPU0的缓存中的，如果CPU0有修改它的缓存中的数据，就会导致两个数据不一样，此时就会出现缓存一致性的问题。
#### 2.2 DMA与高速缓存一致性
	DMA直接操作系统总线来读写内存，CPU并不会感知到，这也就导致DMA如果修改的内存地址在CPU缓存中有副本，那么CPU并不知道内存数据被修改了，依然访问缓存从而导致读取了旧的数据。
	对于DMA缓冲区的操作可以根据数据流向分为两种情况：
		1. 从DMA缓冲区(内存)到设备的FIFO缓冲区
		2. 从设备的FIFO缓冲区到DMA缓冲区。
![DMA](https://github.com/Liyaxxx/Photo/blob/main/%E5%86%85%E5%AD%98.png "DMA")

	对于一致性主要考虑两个问题，在启动DMA之前：
		1. 最新的数据在哪里？是CPU侧还是设备侧。
		2. DMA缓冲区对应的高速缓存数据是最新的还是过时的。
	
### 3.MESI协议
	M：Modify	修改
	E：Exclusive	独占
	S:Shared	分享
	I：Invalid	失效
	「修改」状态代表该CacheBlock上的数据已经被更新过，但是还没有写到内存里。而「失效」状态，表示的是这个CacheBlock里的数据已经失效了，不可以读取该状态的数据。
	「独占」和「共享」状态都代表 Cache Block 里的数据是干净的，也就是说，这个时候CacheBlock 里的数据和内存里面的数据是一致性的。「独占」和「共享」的差别在于，独占状态的时候，数据只存储在一个CPU核心的Cache里，而其他CPU核心的Cache没有该数据。这个时候，如果要向独占的Cache写数据，就可以直接自由地写入，而不需要通知其他CPU核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。
	另外，在「独占」状态下的数据，如果有其他核心从内存读取了相同的数据到各自的Cache，那么这个时候，独占状态下的数据就会变成共享状态。
	「共享」状态代表着相同的数据在多个CPU核心的Cache里都有，所以当我们要更新Cache里面的数据的时候，不能直接修改，而是要先向所有的其他CPU核心广播一个请求，要求先把其他核心的Cache中对应的CacheLine标记为「无效」状态，然后再更新当前Cache里面的数据。
